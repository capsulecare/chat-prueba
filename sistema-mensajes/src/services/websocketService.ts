import { Client } from '@stomp/stompjs';
import type { MensajeWebSocketDTO, UsuarioEscribiendoDTO, MarcarLeidosRequest, Mensaje } from '../types/api';
import { API_CONFIG } from '../config/api';

export type MessageHandler = (message: Mensaje) => void;
export type TypingHandler = (userId: number) => void;
export type ReadHandler = (userId: number) => void;

class WebSocketService {
  private client: Client | null = null;
  private connected = false;
  private subscriptions = new Map<string, any>();
  private connectionPromise: Promise<void> | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;

  connect(): Promise<void> {
    // ‚úÖ Evitar m√∫ltiples conexiones simult√°neas
    if (this.connectionPromise) {
      console.log('üîÑ Conexi√≥n ya en progreso, reutilizando promesa...');
      return this.connectionPromise;
    }

    if (this.connected && this.client) {
      console.log('‚úÖ WebSocket ya conectado');
      return Promise.resolve();
    }

    console.log('üöÄ Iniciando nueva conexi√≥n WebSocket...');
    console.log('üîó URL: ws://localhost:8080/ws');

    this.connectionPromise = new Promise((resolve, reject) => {
      this.client = new Client({
        // ‚úÖ CONFIGURACI√ìN MEJORADA
        webSocketFactory: () => {
          const ws = new WebSocket('ws://localhost:8080/ws');
          
          // ‚úÖ Logs detallados para debugging
          ws.onopen = () => console.log('üîå WebSocket nativo conectado');
          ws.onerror = (error) => console.error('‚ùå WebSocket nativo error:', error);
          ws.onclose = (event) => console.log('üîå WebSocket nativo cerrado:', event.code, event.reason);
          
          return ws;
        },
        
        // ‚úÖ CONFIGURACI√ìN DE RECONEXI√ìN MEJORADA
        reconnectDelay: 5000,
        heartbeatIncoming: 10000,
        heartbeatOutgoing: 10000,
        
        // ‚úÖ CONFIGURACI√ìN DE TIMEOUTS
        connectionTimeout: 10000,
        
        debug: (str) => {
          console.log('üîç STOMP Debug:', str);
        },
        
        onConnect: (frame) => {
          console.log('‚úÖ STOMP conectado exitosamente!', frame);
          this.connected = true;
          this.reconnectAttempts = 0; // ‚úÖ Reset contador
          this.connectionPromise = null;
          resolve();
        },
        
        onStompError: (frame) => {
          console.error('‚ùå STOMP error:', frame.headers['message']);
          console.error('‚ùå Detalles:', frame.body);
          this.connected = false;
          this.connectionPromise = null;
          reject(new Error(`STOMP error: ${frame.headers['message']}`));
        },
        
        onWebSocketError: (error) => {
          console.error('‚ùå WebSocket error:', error);
          this.connected = false;
          this.connectionPromise = null;
          
          // ‚úÖ MANEJO DE RECONEXI√ìN
          if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            console.log(`üîÑ Intento de reconexi√≥n ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
            setTimeout(() => {
              this.connectionPromise = null;
              this.connect();
            }, 2000 * this.reconnectAttempts);
          } else {
            console.error('‚ùå M√°ximo de intentos de reconexi√≥n alcanzado');
            reject(error);
          }
        },
        
        onDisconnect: (frame) => {
          console.log('üîå STOMP desconectado:', frame);
          this.connected = false;
          this.subscriptions.clear();
          this.connectionPromise = null;
        },
        
        onWebSocketClose: (event) => {
          console.log('üîå WebSocket cerrado:', event.code, event.reason);
          this.connected = false;
          this.connectionPromise = null;
          
          // ‚úÖ RECONEXI√ìN AUTOM√ÅTICA si no fue cierre intencional
          if (event.code !== 1000 && this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            console.log(`üîÑ Reconexi√≥n autom√°tica ${this.reconnectAttempts}/${this.maxReconnectAttempts}`);
            setTimeout(() => {
              this.connectionPromise = null;
              this.connect();
            }, 3000);
          }
        }
      });

      try {
        console.log('üîÑ Activando cliente STOMP...');
        this.client.activate();
      } catch (error) {
        console.error('‚ùå Error activando cliente:', error);
        this.connectionPromise = null;
        reject(error);
      }
    });

    return this.connectionPromise;
  }

  disconnect(): void {
    if (this.client && this.connected) {
      console.log('üîå Desconectando WebSocket...');
      this.subscriptions.forEach((subscription) => {
        try {
          subscription.unsubscribe();
        } catch (error) {
          console.warn('Error al desuscribirse:', error);
        }
      });
      this.subscriptions.clear();
      this.client.deactivate();
      this.connected = false;
      this.connectionPromise = null;
      this.reconnectAttempts = 0;
    }
  }

  // ‚úÖ RESTO DE M√âTODOS SIN CAMBIOS
  subscribeToConversation(
    idConversacion: number, 
    onMessage: MessageHandler
  ): () => void {
    if (!this.client || !this.connected) {
      throw new Error('WebSocket not connected');
    }

    const topic = API_CONFIG.WEBSOCKET.TOPICS.CONVERSACION(idConversacion);
    const subscriptionKey = `conversation-${idConversacion}`;
    
    if (this.subscriptions.has(subscriptionKey)) {
      console.log('üîÑ Ya suscrito a:', topic);
      const existingSubscription = this.subscriptions.get(subscriptionKey);
      return () => {
        existingSubscription.unsubscribe();
        this.subscriptions.delete(subscriptionKey);
      };
    }

    console.log('üì° Suscribi√©ndose a:', topic);
    
    const subscription = this.client.subscribe(topic, (message) => {
      try {
        console.log('üì® Mensaje WebSocket recibido:', message.body);
        const parsedMessage: Mensaje = JSON.parse(message.body);
        console.log('‚úÖ Mensaje parseado:', parsedMessage);
        onMessage(parsedMessage);
      } catch (error) {
        console.error('‚ùå Error parsing message:', error, message.body);
      }
    });

    this.subscriptions.set(subscriptionKey, subscription);

    return () => {
      console.log('üö´ Desuscribi√©ndose de:', topic);
      try {
        subscription.unsubscribe();
        this.subscriptions.delete(subscriptionKey);
      } catch (error) {
        console.warn('Error al desuscribirse:', error);
      }
    };
  }

  subscribeToTyping(
    idConversacion: number, 
    onTyping: TypingHandler
  ): () => void {
    if (!this.client || !this.connected) {
      throw new Error('WebSocket not connected');
    }

    const topic = API_CONFIG.WEBSOCKET.TOPICS.TYPING(idConversacion);
    const subscriptionKey = `typing-${idConversacion}`;
    
    if (this.subscriptions.has(subscriptionKey)) {
      console.log('üîÑ Ya suscrito a typing:', topic);
      const existingSubscription = this.subscriptions.get(subscriptionKey);
      return () => {
        existingSubscription.unsubscribe();
        this.subscriptions.delete(subscriptionKey);
      };
    }

    console.log('‚å®Ô∏è Suscribi√©ndose a typing:', topic);
    
    const subscription = this.client.subscribe(topic, (message) => {
      try {
        const userId: number = JSON.parse(message.body);
        console.log('‚å®Ô∏è Usuario escribiendo:', userId);
        onTyping(userId);
      } catch (error) {
        console.error('‚ùå Error parsing typing notification:', error);
      }
    });

    this.subscriptions.set(subscriptionKey, subscription);

    return () => {
      try {
        subscription.unsubscribe();
        this.subscriptions.delete(subscriptionKey);
      } catch (error) {
        console.warn('Error al desuscribirse de typing:', error);
      }
    };
  }

  subscribeToRead(
    idConversacion: number, 
    onRead: ReadHandler
  ): () => void {
    if (!this.client || !this.connected) {
      throw new Error('WebSocket not connected');
    }

    const topic = API_CONFIG.WEBSOCKET.TOPICS.LEIDO(idConversacion);
    const subscriptionKey = `read-${idConversacion}`;
    
    if (this.subscriptions.has(subscriptionKey)) {
      console.log('üîÑ Ya suscrito a read:', topic);
      const existingSubscription = this.subscriptions.get(subscriptionKey);
      return () => {
        existingSubscription.unsubscribe();
        this.subscriptions.delete(subscriptionKey);
      };
    }

    const subscription = this.client.subscribe(topic, (message) => {
      try {
        const userId: number = JSON.parse(message.body);
        onRead(userId);
      } catch (error) {
        console.error('‚ùå Error parsing read notification:', error);
      }
    });

    this.subscriptions.set(subscriptionKey, subscription);

    return () => {
      try {
        subscription.unsubscribe();
        this.subscriptions.delete(subscriptionKey);
      } catch (error) {
        console.warn('Error al desuscribirse de read:', error);
      }
    };
  }

  sendMessage(message: MensajeWebSocketDTO): void {
    if (!this.client || !this.connected) {
      throw new Error('WebSocket not connected');
    }

    console.log('üì§ Enviando mensaje por WebSocket:', message);
    
    try {
      this.client.publish({
        destination: API_CONFIG.WEBSOCKET.ENDPOINTS.ENVIAR_MENSAJE,
        body: JSON.stringify(message),
      });
      
      console.log('‚úÖ Mensaje enviado a:', API_CONFIG.WEBSOCKET.ENDPOINTS.ENVIAR_MENSAJE);
    } catch (error) {
      console.error('‚ùå Error enviando mensaje:', error);
      throw error;
    }
  }

  sendTypingNotification(typing: UsuarioEscribiendoDTO): void {
    if (!this.client || !this.connected) {
      console.warn('‚ö†Ô∏è WebSocket no conectado, no se puede enviar typing notification');
      return;
    }

    try {
      this.client.publish({
        destination: API_CONFIG.WEBSOCKET.ENDPOINTS.TYPING,
        body: JSON.stringify(typing),
      });
    } catch (error) {
      console.error('‚ùå Error enviando typing notification:', error);
    }
  }

  markAsRead(request: MarcarLeidosRequest): void {
    if (!this.client || !this.connected) {
      console.warn('‚ö†Ô∏è WebSocket no conectado, no se puede marcar como le√≠do');
      return;
    }

    try {
      this.client.publish({
        destination: API_CONFIG.WEBSOCKET.ENDPOINTS.LEER_MENSAJES,
        body: JSON.stringify(request),
      });
    } catch (error) {
      console.error('‚ùå Error marcando como le√≠do:', error);
    }
  }

  isConnected(): boolean {
    return this.connected && this.client !== null;
  }
}

export const websocketService = new WebSocketService();